import { portal } from './robo.js';
import { timeout, getSage } from '../cli/utils/utils.js';
import { getConfig } from './config.js';
import { discordLogger, BUFFER, TIMEOUT, DEFAULT_CONFIG } from './constants.js';
import { printErrorResponse } from './debug.js';
import { color } from './color.js';
import g from 'node:path';

const I=["boolean","integer","number","string",void 0];async function _(e,s){const r=portal.commands.get(s);if(!r){discordLogger.error(`No command matching ${s} was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled command from module: ${color.bold(r.module)}`);return}try{for(const a of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(a.plugin?.path??".",a.path))}`);const l=await a.handler.default({payload:[e],record:r});if(l&&l.abort){discordLogger.debug(`Middleware aborted autocomplete: ${color.bold(e.commandName)}`);return}}}catch(a){discordLogger.error("Aborting due to middleware error:",a);return}const d=getConfig();try{discordLogger.debug(`Executing autocomplete handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`);const a=[r.handler.autocomplete(e)],l=d?.timeouts?.autocomplete;l&&a.push(timeout(()=>[],l));const t=await Promise.race(a);if(!t)throw new Error("Autocomplete timed out");await e.respond(t);}catch(a){discordLogger.error("Autocomplete error:",a);}}async function V(e,s){const r=portal.commands.get(s);if(!r){discordLogger.error(`No command matching "${s}" was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled command from module: ${color.bold(r.module)}`);return}try{for(const t of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(t.plugin?.path??".",t.path))}`);const i=await t.handler.default({payload:[e],record:r});if(i&&i.abort){discordLogger.debug(`Middleware aborted command: ${color.bold(s)}`);return}}}catch(t){discordLogger.error("Aborting due to middleware error:",t);return}const d=r.handler.config,a=getConfig(),l=getSage(d,a);discordLogger.debug("Sage options:",l);try{if(discordLogger.debug(`Executing command handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`),!r.handler.default)throw `Missing default export function for command: ${color.bold("/"+s)}`;j(e);const t=v(e,d?.options),i=r.handler.default(e,t),u=[];let n;if(l.defer&&i instanceof Promise){const p=timeout(()=>BUFFER,l.deferBuffer),$=await Promise.race([i,p]);if($===BUFFER&&!e.replied){if(discordLogger.debug("Sage is deferring async command..."),u.push(i),!e.deferred)try{await e.deferReply({ephemeral:l.ephemeral});}catch(w){const P=w instanceof Error?w.message:w;if(!P.includes("Unknown interaction")&&!P.includes("Interaction has already been acknowledged"))throw w;discordLogger.debug("Interaction was already handled, skipping Sage deferral");}}else n=$;}else i instanceof Promise&&u.push(i);if(u.length>0){if(a?.timeouts?.commandDeferral&&u.push(timeout(()=>TIMEOUT,a.timeouts.commandDeferral)),n=await Promise.race(u),n===TIMEOUT)throw new Error("Command timed out")}else i instanceof Promise||(n=i);if(n===void 0){discordLogger.debug("Command returned void, skipping response");return}discordLogger.debug("Sage is handling reply:",n);const c=typeof n=="string"?{content:n}:n,b=!c.id;if(b&&e.deferred)await e.editReply(c);else if(b)await e.reply(c);else {const p=color.bold("/"+s);discordLogger.warn(`Invalid return value for command ${p}. Did you accidentally return a message object?`);}}catch(t){discordLogger.error(t),printErrorResponse(t,e);}}async function W(e,s){const r=portal.context.get(s);if(!r){discordLogger.error(`No context menu command matching "${s}" was found.`);return}if(!portal.module(r.module).isEnabled){discordLogger.debug(`Tried to execute disabled context menu command from module: ${color.bold(r.module)}`);return}try{for(const t of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(t.plugin?.path??".",t.path))}`);const i=await t.handler.default({payload:[e],record:r});if(i&&i.abort){discordLogger.debug(`Middleware aborted context command: ${color.bold(s)}`);return}}}catch(t){discordLogger.error("Aborting due to middleware error:",t);return}const d=r.handler.config,a=getConfig(),l=getSage(d,a);discordLogger.debug("Sage options:",l);try{if(discordLogger.debug(`Executing context menu handler: ${color.bold(g.join(r.plugin?.path??".",r.path))}`),!r.handler.default)throw `Missing default export function for command: ${color.bold("/"+s)}`;let t;e.isMessageContextMenuCommand()?t=e.targetMessage:e.isUserContextMenuCommand()&&(t=e.targetUser);const i=r.handler.default(e,t),u=[];let n;if(l.defer&&i instanceof Promise){const b=timeout(()=>BUFFER,l.deferBuffer),p=await Promise.race([i,b]);p===BUFFER&&!e.replied?(discordLogger.debug("Sage is deferring async command..."),u.push(i),e.deferred||await e.deferReply({ephemeral:l.ephemeral})):n=p;}if(u.length>0){if(a?.timeouts?.commandDeferral&&u.push(timeout(()=>TIMEOUT,a.timeouts.commandDeferral)),n=await Promise.race(u),n===TIMEOUT)throw new Error("Context menu command timed out")}else i instanceof Promise||(n=i);if(n===void 0){discordLogger.debug("Context menu command returned void, skipping response");return}discordLogger.debug("Sage is handling reply:",n);const c=typeof n=="string"?{content:n}:n;e.deferred?await e.editReply(c):await e.reply(c);}catch(t){discordLogger.error(t),printErrorResponse(t,e);}}async function k(e,s,...r){const d=portal.events.get(s);if(!d?.length)return Promise.resolve();const a=getConfig(),l=s.startsWith("_");await Promise.all(d.map(async t=>{try{if(discordLogger.debug(`Executing event handler: ${color.bold(g.join(t.plugin?.path??".",t.path))}`),!t.handler.default)throw `Missing default export function for event: ${color.bold(s)}`;if(!portal.module(t.module).isEnabled){discordLogger.debug(`Tried to execute disabled event from module: ${color.bold(t.module)}`);return}try{for(const n of portal.middleware){discordLogger.debug(`Executing middleware: ${color.bold(g.join(n.plugin?.path??".",n.path))}`);const c=await n.handler.default({payload:r,record:t});if(c&&c.abort){discordLogger.debug(`Middleware aborted event: ${color.bold(s)}`);return}}}catch(n){discordLogger.error("Aborting due to middleware error:",n);return}const i=t.handler.default(...r,e?.get(t.plugin?.name)?.options);if(!l)return await i;const u=timeout(()=>TIMEOUT,a?.timeouts?.lifecycle||DEFAULT_CONFIG.timeouts.lifecycle);return await Promise.race([i,u])}catch(i){try{const u=e?.get(t.plugin?.name)?.metaOptions??{};let n;i===TIMEOUT?(n=`${s} lifecycle event handler timed out`,discordLogger.warn(n)):t.plugin?s==="_start"&&u.failSafe?(n=`${t.plugin.name} plugin failed to start`,discordLogger.warn(n,i)):(n=`${t.plugin.name} plugin error in event ${s}`,discordLogger.error(n,i)):(n=`Error executing ${s} event handler`,discordLogger.error(n,i)),printErrorResponse(i,r[0],n,t);}catch(u){discordLogger.error("Error handling event error...",u);}}}));}function G(e){return e}function v(e,s){const r={};return s?.forEach(d=>{if(I.includes(d.type))r[d.name]=e.options.get(d.name)?.value;else if(d.type==="attachment")r[d.name]=e.options.get(d.name)?.attachment;else if(d.type==="channel")r[d.name]=e.options.get(d.name)?.channel;else if(d.type==="mention"){const a=e.options.get(d.name);r[d.name]=a?.member??a?.role;}else d.type==="role"?r[d.name]=e.options.get(d.name)?.role:d.type==="user"?r[d.name]=e.options.get(d.name)?.user:d.type==="member"&&(r[d.name]=e.options.get(d.name)?.member);}),r}function j(e){const s=e.deferReply.bind(e);let r,d=!1;e.deferReply=async function(a){return r?a?.fetchReply&&!d?this.fetchReply():r:a?.fetchReply?(r=s(a),d=!0,r):(r=s(a),r)};}

export { G as createCommandConfig, _ as executeAutocompleteHandler, V as executeCommandHandler, W as executeContextHandler, k as executeEventHandler, v as extractCommandOptions };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=handlers.js.map