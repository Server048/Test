{"version":3,"sources":["../../src/core/env.ts"],"names":["IS_BUN_RUNTIME","logger","existsSync","readFileSync","readFile","path","_globalOverwrites","Env","schema","key","keys","result","k","envKey","envValue","options","filePath","getFilePath","envContent","newEnv","parseEnvFile","applyEnv","env","newEnvVars","overwrite","varSubstitutionRegex","envClone","visited","value","_","varName","err","mode","envFileContent","lines","commentRegex","quotesRegex","escapedCharsRegex","currentLine","i","delimiterIndex","setGlobalOverwrites","overwrites"],"mappings":"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","sourcesContent":["import { IS_BUN_RUNTIME } from '../cli/utils/runtime-utils.js'\nimport { logger } from './logger.js'\nimport { existsSync, readFileSync } from 'node:fs'\nimport { readFile } from 'node:fs/promises'\nimport path from 'node:path'\n\ninterface EnvVariable {\n\tenv: string\n\tdefault?: string\n}\n\nexport interface LoadOptions {\n\t/**\n\t * The mode to load environment variables for.\n\t */\n\tmode?: string\n\n\t/**\n\t * The path to the environment file. Defaults to `.env`.\n\t */\n\tpath?: string\n\n\t/**\n\t * Whether to overwrite existing environment variables.\n\t * Can be a boolean or an array of keys to overwrite.\n\t */\n\toverwrite?: boolean | string[]\n}\n\ntype IsLeaf<T> = T extends { env: string } ? true : false\n\ntype DotPaths<T> = T extends object\n\t? IsLeaf<T> extends true\n\t\t? never\n\t\t: {\n\t\t\t\t[K in keyof T & string]: IsLeaf<T[K]> extends true ? `${K}` : `${K}.${DotPaths<T[K]>}`\n\t\t  }[keyof T & string]\n\t: never\n\ntype ValueAtPath<T, P extends string> = P extends `${infer Key}.${infer Rest}`\n\t? Key extends keyof T\n\t\t? ValueAtPath<T[Key], Rest>\n\t\t: never\n\t: P extends keyof T\n\t? IsLeaf<T[P]> extends true\n\t\t? T[P] extends { env: infer E }\n\t\t\t? E\n\t\t\t: never\n\t\t: never\n\t: never\n\n// Variable keys to always overwrite unless specified otherwise\nlet _globalOverwrites: string[] = []\n\n/**\n * Sometimes you need to store sensitive information, like API keys, database URLs, or Discord Credentials.\n *\n * ```ts\n * import { Env } from 'robo'\n *\n * Env.loadSync({ mode: 'dev' })\n * Env.data().NODE_ENV // 'development'\n * ```\n *\n * Use the `Env` class to load environment variables from a file and access them in a type-safe way.\n *\n * [**Learn more:** Environment Variables](https://robojs.dev/robojs/environment-variables)\n */\nexport class Env<T> {\n\tprivate _variables: T\n\tprivate static _data: Record<string, string>\n\n\t/**\n\t * Creates a new instance of the Env class with the specified schema with type-checking and default values.\n\t *\n\t * ```ts\n\t * const env = new Env({\n\t * \tdiscord: {\n\t * \t\tclientId: { env: 'DISCORD_CLIENT_ID' }\n\t * \t},\n\t * \texample: {\n\t * \t\tdefault: 'This is an example',\n\t * \t\tenv: 'EXAMPLE_ENV'\n\t * \t},\n\t * \tnodeEnv: { env: 'NODE_ENV' }\n\t * })\n\t *\n\t * // Returns the value of the DISCORD_CLIENT_ID environment variable\n\t * env.get('discord.clientId')\n\t * ```\n\t *\n\t * @param schema - The schema of environment variables to use for type-checking and default values.\n\t */\n\tconstructor(schema: T) {\n\t\tthis._variables = schema\n\t}\n\n\t/**\n\t * Retrieves the value of the environment variable specified by the dot-separated key.\n\t * If the environment variable is not set, it returns the default value if provided.\n\t *\n\t * @param key - The dot-separated path to the environment variable in the schema.\n\t * @returns The value of the environment variable or its default.\n\t */\n\tpublic get<K extends DotPaths<T>>(key: K): ValueAtPath<T, K> {\n\t\tconst keys = key.split('.')\n\t\tlet result: unknown = this._variables\n\n\t\t// Traverse the schema to locate the desired key\n\t\tfor (const k of keys) {\n\t\t\tif (typeof result === 'object' && result !== null && k in result) {\n\t\t\t\tresult = (result as Record<string, unknown>)[k]\n\t\t\t} else {\n\t\t\t\tthrow new Error(`Invalid key path: ${key}`)\n\t\t\t}\n\t\t}\n\n\t\t// At this point, result should be an EnvVariable\n\t\tif (typeof result === 'object' && result !== null && 'env' in result) {\n\t\t\tconst envKey = (result as EnvVariable).env\n\t\t\tconst envValue = process.env[envKey]\n\n\t\t\tif (envValue !== undefined) {\n\t\t\t\treturn envValue as ValueAtPath<T, K>\n\t\t\t} else if ('default' in result && (result as EnvVariable).default !== undefined) {\n\t\t\t\treturn (result as EnvVariable).default as ValueAtPath<T, K>\n\t\t\t} else {\n\t\t\t\treturn undefined as ValueAtPath<T, K>\n\t\t\t}\n\t\t}\n\n\t\tthrow new Error(`Invalid schema configuration for key: ${key}`)\n\t}\n\n\t/**\n\t * @returns The environment variables that have been loaded most recently.\n\t */\n\tpublic static data() {\n\t\treturn this._data\n\t}\n\n\t/**\n\t * Loads environment variables from a file and applies them to the current process.\n\t *\n\t * @param options - Customize where the file path, mode, and overwrite behavior.\n\t * @returns Record object containing loaded environment variables.\n\t */\n\tpublic static async load(options: LoadOptions = {}) {\n\t\tconst filePath = getFilePath(options)\n\n\t\tif (filePath) {\n\t\t\tconst envContent = await readFile(filePath, 'utf-8')\n\t\t\tconst newEnv = parseEnvFile(envContent)\n\t\t\tEnv._data = newEnv\n\n\t\t\treturn applyEnv(options, newEnv)\n\t\t} else {\n\t\t\treturn {}\n\t\t}\n\t}\n\n\t/**\n\t * Loads environment variables from a file and applies them to the current process.\n\t *\n\t * **This operation is synchronous and will block the event loop.** Use {@link load} for asynchronous loading.\n\t *\n\t * @param options - Customize where the file path, mode, and overwrite behavior.\n\t * @returns Record object containing loaded environment variables.\n\t */\n\tpublic static loadSync(options: LoadOptions = {}) {\n\t\tconst filePath = getFilePath(options)\n\n\t\tif (filePath) {\n\t\t\tconst envContent = readFileSync(filePath, 'utf-8')\n\t\t\tconst newEnv = parseEnvFile(envContent)\n\t\t\tEnv._data = newEnv\n\n\t\t\treturn applyEnv(options, newEnv)\n\t\t} else {\n\t\t\treturn {}\n\t\t}\n\t}\n}\n\nexport const env = new Env({\n\tdiscord: {\n\t\tclientId: { env: 'DISCORD_CLIENT_ID' },\n\t\tdebugChannelId: { env: 'DISCORD_DEBUG_CHANNEL_ID' },\n\t\tguildId: { env: 'DISCORD_GUILD_ID' },\n\t\ttoken: { env: 'DISCORD_TOKEN' }\n\t},\n\tnodeEnv: { env: 'NODE_ENV' },\n\troboplay: {\n\t\tapi: {\n\t\t\tenv: 'ROBOPLAY_API',\n\t\t\tdefault: 'https://api.roboplay.dev'\n\t\t},\n\t\tdebug: { env: 'ROBOPLAY_DEBUG' },\n\t\tenv: { env: 'ROBOPLAY_ENV' },\n\t\tfrontend: {\n\t\t\tenv: 'ROBOPLAY_FRONTEND',\n\t\t\tdefault: 'https://roboplay.dev'\n\t\t}\n\t}\n})\n\nfunction applyEnv(options: LoadOptions, newEnvVars: Record<string, string>) {\n\tconst { overwrite = _globalOverwrites } = options\n\tconst varSubstitutionRegex = /\\${(.+?)}/g\n\n\t// Create a clone of process.env to maintain a consistent state in case of an error\n\tconst envClone = { ...process.env }\n\n\ttry {\n\t\tfor (const key in newEnvVars) {\n\t\t\t// Don't overwrite existing values unless specified\n\t\t\tconst shouldOverwrite = overwrite === true || (Array.isArray(overwrite) && overwrite.includes(key))\n\n\t\t\tif (!shouldOverwrite && key in envClone) {\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tconst visited = new Set<string>()\n\t\t\tlet value = newEnvVars[key]\n\n\t\t\twhile (varSubstitutionRegex.test(value)) {\n\t\t\t\tvalue = value.replace(varSubstitutionRegex, (_, varName) => {\n\t\t\t\t\tif (visited.has(varName)) {\n\t\t\t\t\t\tthrow new Error(`Circular reference detected in environment variable \"${key}\"`)\n\t\t\t\t\t}\n\t\t\t\t\tvisited.add(varName)\n\t\t\t\t\treturn envClone[varName] || newEnvVars[varName] || ''\n\t\t\t\t})\n\t\t\t}\n\n\t\t\tenvClone[key] = value\n\t\t}\n\n\t\tObject.assign(process.env, envClone)\n\t} catch (err) {\n\t\tlogger.error(`Could not load environment variables:`, err)\n\t}\n\n\treturn newEnvVars\n}\n\nfunction getFilePath(options: LoadOptions): string | null {\n\t// No need to load .env file if using Bun (it's already loaded)\n\tif (IS_BUN_RUNTIME) {\n\t\treturn null\n\t}\n\n\t// Look for .env.{mode} file first, then fallback to standard .env\n\tconst { mode } = options\n\tlet { path: filePath = path.join(process.cwd(), '.env') } = options\n\n\tif (mode && existsSync(filePath + '.' + mode)) {\n\t\tlogger.debug('Found .env file for mode:', mode, ':', filePath + '.' + mode)\n\t\tfilePath = path.join(process.cwd(), '.env' + '.' + mode)\n\t}\n\tif (!existsSync(filePath)) {\n\t\tlogger.debug(`No .env file found at \"${filePath}\"`)\n\t\treturn\n\t}\n\n\treturn filePath\n}\n\nfunction parseEnvFile(envFileContent: string): Record<string, string> {\n\tconst lines = envFileContent.split('\\n')\n\tconst commentRegex = /^\\s*#/\n\tconst quotesRegex = /^['\"]/\n\tconst escapedCharsRegex = /\\\\(.)/g\n\n\tlet currentLine = ''\n\tconst newEnvVars: { [key: string]: string } = {}\n\n\tfor (let i = 0; i < lines.length; i++) {\n\t\tcurrentLine += lines[i]\n\n\t\t// Ignore comments\n\t\tif (commentRegex.test(currentLine)) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue\n\t\t}\n\n\t\t// Multiline support\n\t\tif (currentLine.endsWith('\\\\')) {\n\t\t\tcurrentLine = currentLine.slice(0, -1)\n\t\t\tcontinue\n\t\t}\n\n\t\t// Find first index of '=', and split key/value there\n\t\tconst delimiterIndex = currentLine.indexOf('=')\n\t\tif (delimiterIndex === -1) {\n\t\t\tcurrentLine = ''\n\t\t\tcontinue // Ignore lines that aren't key-value pairs\n\t\t}\n\n\t\tconst key = currentLine.substring(0, delimiterIndex).trim()\n\t\tlet value = currentLine.substring(delimiterIndex + 1).trim()\n\n\t\t// Remove surrounding quotes and unescape\n\t\tif (quotesRegex.test(value)) {\n\t\t\tvalue = value.slice(1, -1).replace(escapedCharsRegex, '$1')\n\t\t}\n\n\t\tnewEnvVars[key] = value\n\t\tcurrentLine = ''\n\t}\n\n\treturn newEnvVars\n}\n\nexport function setGlobalOverwrites(overwrites: string[]) {\n\t_globalOverwrites = overwrites\n}\n"]}