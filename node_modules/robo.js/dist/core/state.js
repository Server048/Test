import { FLASHCORE_KEYS } from './constants.js';
import { logger } from './logger.js';
import { Flashcore } from './flashcore.js';

const r={};class o{static _prefixes=new Set;_prefix;_options;constructor(t,n){this._prefix=t,this._options=n,this.fork=this.fork.bind(this),this.getState=this.getState.bind(this),this.setState=this.setState.bind(this);}static fork(t,n){return o._prefixes.add(t),new o(t,n)}static listForks(){return new Array(...o._prefixes)}static get(t,n){return g(t,n)}static set(t,n,s){d(t,n,s);}fork(t,n){return new o(`${this._prefix}__${t}`,n)}getState(t){return g(`${this._prefix}__${t}`)}setState(t,n,s){d(`${this._prefix}__${t}`,n,{...s??{},persist:s?.persist??this._options?.persist});}}const S=["String","Number","Boolean","Array","Object"];function l(e,t={value:!1}){if(typeof e!="function"){if(e!==null&&typeof e=="object")if(S.includes(e.constructor.name)){if(Array.isArray(e))return e.map(n=>l(n,t)).filter(n=>n!==void 0);{const n={};for(const s in e){const i=l(e[s],t);i!==void 0&&(n[s]=i);}return n}}else {t.value||(logger.warn("Removed state value as it is not serializable:",e),t.value=!0);return}return e}}function _(){Object.keys(r).forEach(e=>{delete r[e];});}function g(e,t){return t?.namespace&&(e=`${t.namespace}__${e}`),r[e]??t?.default}function b(e){logger.debug("Loading state...",e),Object.keys(e).forEach(t=>{r[t]=e[t];});}function m(){logger.debug("Saving state...",r),process.send({type:"state-save",state:r});}function d(e,t,n){const{persist:s}=n??{};n?.namespace&&(e=`${n.namespace}__${e}`);let i=t;if(typeof t=="function"){const p=r[e];i=t(p);}return r[e]=i,s&&(async()=>{const c=await Flashcore.get(FLASHCORE_KEYS.state)??{};c[e]=i,Flashcore.set(FLASHCORE_KEYS.state,c);})(),i}

export { o as State, _ as clearState, g as getState, b as loadState, l as removeInstances, m as saveState, d as setState, r as state };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=state.js.map