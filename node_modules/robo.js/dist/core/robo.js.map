{"version":3,"sources":["../../src/core/robo.ts"],"names":["color","registerProcessEvents","Compiler","Client","Collection","Events","getConfig","loadConfig","FLASHCORE_KEYS","discordLogger","logger","env","Env","executeAutocompleteHandler","executeCommandHandler","executeContextHandler","executeEventHandler","hasProperties","PackageDir","Flashcore","prepareFlashcore","Mode","loadState","Portal","path","isMainThread","parentPort","Robo","restart","start","stop","build","client","portal","plugins","options","buildAction","optionsClient","shard","stateLoad","config","ShardingManager","shardPath","manager","result","mode","stateStart","state","loadPluginData","key","onlyAuto","event","args","interaction","commandKey","getCommandKey","exitCode","commandKeys","collection","plugin","name","metaOptions"],"mappings":"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","sourcesContent":["import { color } from './color.js'\nimport { registerProcessEvents } from './process.js'\nimport { Compiler } from './../cli/utils/compiler.js'\nimport { Client, Collection, Events } from 'discord.js'\nimport { getConfig, loadConfig } from './config.js'\nimport { FLASHCORE_KEYS, discordLogger } from './constants.js'\nimport { logger } from './logger.js'\nimport { env, Env } from './env.js'\nimport {\n\texecuteAutocompleteHandler,\n\texecuteCommandHandler,\n\texecuteContextHandler,\n\texecuteEventHandler\n} from './handlers.js'\nimport { hasProperties, PackageDir } from '../cli/utils/utils.js'\nimport { Flashcore, prepareFlashcore } from './flashcore.js'\nimport { Mode } from './mode.js'\nimport { loadState } from './state.js'\nimport Portal from './portal.js'\nimport path from 'node:path'\nimport { isMainThread, parentPort } from 'node:worker_threads'\nimport type { HandlerRecord, PluginData } from '../types/index.js'\nimport type { AutocompleteInteraction, CommandInteraction } from 'discord.js'\nimport type { BuildCommandOptions } from '../cli/commands/build/index.js'\n\n/**\n * Robo is the main entry point for your bot. It provides a simple API for starting, stopping, and restarting your Robo.\n *\n * ```ts\n * import { Robo } from 'robo.js'\n *\n * Robo.start()\n * ```\n *\n * You do not normally need to use this API directly, as the CLI will handle starting and stopping for you.\n *\n * [**Learn more:** Robo](https://robojs.dev/discord-bots/migrate)\n */\nexport const Robo = { restart, start, stop, build }\n\n// Each Robo instance has its own client, exported for convenience\nexport let client: Client\n\n// A Portal is exported with each Robo to allow for dynamic controls\nexport const portal = new Portal()\n\n// Be careful, plugins may contain sensitive data in their config\nlet plugins: Collection<string, PluginData>\n\ninterface StartOptions {\n\tclient?: Client\n\tshard?: string | boolean\n\tstateLoad?: Promise<void>\n}\n\ntype BuildOptions = BuildCommandOptions\n\n/**\n * Builds your Robo instance. Similar to running `robo build` from the CLI.\n *\n * @param options - Options for building your Robo instance, similar to CLI options\n * @returns A promise that resolves when Robo has finished building\n */\nexport async function build(options?: BuildOptions) {\n\tconst { buildAction } = await import('../cli/commands/build/index.js')\n\tawait buildAction([], {\n\t\texit: false,\n\t\t...(options ?? {})\n\t})\n}\n\n/**\n * Starts your Robo instance. Similar to running `robo start` from the CLI.\n *\n * @param options - Options for starting your Robo instance\n * @returns A promise that resolves when Robo has started\n */\nasync function start(options?: StartOptions) {\n\tconst { client: optionsClient, shard, stateLoad } = options ?? {}\n\n\t// Important! Register process events before doing anything else\n\t// This ensures the \"ready\" signal is sent to the parent process\n\tregisterProcessEvents()\n\n\t// Load config and manifest up next!\n\t// This makes them available globally via getConfig() and getManifest()\n\tconst [config] = await Promise.all([loadConfig(), Compiler.useManifest()])\n\tlogger({\n\t\tdrain: config?.logger?.drain,\n\t\tenabled: config?.logger?.enabled,\n\t\tlevel: config?.logger?.level\n\t}).debug('Starting Robo...')\n\n\t// Wanna shard? Delegate to the shard manager and await recursive call\n\tif (shard && config.experimental?.disableBot !== true) {\n\t\tdiscordLogger.debug('Sharding is enabled. Delegating start to shard manager...')\n\t\tconst { ShardingManager } = await import('discord.js')\n\t\tconst shardPath = typeof shard === 'string' ? shard : path.join(PackageDir, 'dist', 'cli', 'shard.js')\n\t\tconst options = typeof config.experimental?.shard === 'object' ? config.experimental.shard : {}\n\t\tconst manager = new ShardingManager(shardPath, { ...options, token: env.get('discord.token') })\n\n\t\tmanager.on('shardCreate', (shard) => discordLogger.debug(`Launched shard`, shard.id))\n\t\tconst result = await manager.spawn()\n\t\tdiscordLogger.debug('Spawned', result.size, 'shard(s)')\n\t\treturn\n\t}\n\n\tconst mode = Mode.get()\n\tawait Env.load({ mode })\n\n\tawait prepareFlashcore()\n\n\t// Wait for states to be loaded\n\tif (stateLoad) {\n\t\t// Await external state promise if provided\n\t\tlogger.debug('Waiting for state...')\n\t\tawait stateLoad\n\t} else {\n\t\t// Load state directly otherwise\n\t\tconst stateStart = Date.now()\n\t\tconst state = await Flashcore.get<Record<string, unknown>>(FLASHCORE_KEYS.state)\n\n\t\tif (state) {\n\t\t\tloadState(state)\n\t\t}\n\t\tlogger.debug(`State loaded in ${Date.now() - stateStart}ms`)\n\t}\n\n\t// Load plugin options\n\tconst plugins = loadPluginData()\n\n\t// Create the new client instance (unless disabled)\n\tif (config.experimental?.disableBot !== true) {\n\t\tclient = optionsClient ?? new Client(config.clientOptions)\n\t} else {\n\t\tlogger.debug(`Bot is disabled, skipping client setup...`)\n\t}\n\n\t// Load the portal (commands, context, events)\n\tawait Portal.open()\n\n\t// Notify lifecycle event handlers\n\tawait executeEventHandler(plugins, '_start', client)\n\n\tif (config.experimental?.disableBot !== true) {\n\t\t// Define event handlers\n\t\tfor (const key of portal.events.keys()) {\n\t\t\tconst onlyAuto = portal.events.get(key).every((event: HandlerRecord<Event>) => event.auto)\n\t\t\tclient.on(key, async (...args) => {\n\t\t\t\tif (!onlyAuto) {\n\t\t\t\t\tdiscordLogger.event(`Event received: ${color.bold(key)}`)\n\t\t\t\t}\n\t\t\t\tdiscordLogger.trace('Event args:', args)\n\n\t\t\t\t// Notify event handler\n\t\t\t\texecuteEventHandler(plugins, key, ...args)\n\t\t\t})\n\t\t}\n\n\t\t// Forward command interactions to our fancy handlers\n\t\tclient.on(Events.InteractionCreate, async (interaction) => {\n\t\t\tif (interaction.isChatInputCommand()) {\n\t\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\t\tdiscordLogger.event(`Received slash command interaction: ${color.bold('/' + commandKey)}`)\n\t\t\t\tdiscordLogger.trace('Slash command interaction:', interaction.toJSON())\n\t\t\t\tawait executeCommandHandler(interaction, commandKey)\n\t\t\t} else if (interaction.isAutocomplete()) {\n\t\t\t\tconst commandKey = getCommandKey(interaction)\n\t\t\t\tdiscordLogger.event(`Received autocomplete interaction for: ${color.bold(interaction.commandName)}`)\n\t\t\t\tdiscordLogger.trace('Autocomplete interaction:', interaction.toJSON())\n\t\t\t\tawait executeAutocompleteHandler(interaction, commandKey)\n\t\t\t} else if (interaction.isContextMenuCommand()) {\n\t\t\t\tdiscordLogger.event(`Received context menu interaction: ${color.bold(interaction.commandName)}`)\n\t\t\t\tdiscordLogger.trace('Context menu interaction:', interaction.toJSON())\n\t\t\t\tawait executeContextHandler(interaction, interaction.commandName)\n\t\t\t}\n\t\t})\n\n\t\t// Log in to Discord with your client's token\n\t\tawait client.login(env.get('discord.token'))\n\t}\n}\n\n/**\n * Stops your Robo instance gracefully. Similar to pressing `Ctrl+C` in the terminal.\n *\n * @param exitCode - The exit code to use when stopping Robo\n */\nasync function stop(exitCode = 0) {\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_stop', client)\n\t\tclient?.destroy()\n\t\tlogger.debug(`Stopped Robo at ` + new Date().toLocaleString())\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(exitCode)\n\t\t} else {\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit(exitCode)\n\t\t}\n\t}\n}\n\n/**\n * Restarts your Robo instance gracefully. Similar to making changes with `robo dev` and restarting.\n *\n * @returns A promise that resolves when Robo has restarted\n */\nasync function restart() {\n\ttry {\n\t\t// Notify lifecycle handler\n\t\tawait executeEventHandler(plugins, '_restart', client)\n\t\tclient?.destroy()\n\t\tlogger.debug(`Restarted Robo at ` + new Date().toLocaleString())\n\t} finally {\n\t\tif (isMainThread) {\n\t\t\tprocess.exit(0)\n\t\t} else {\n\t\t\tawait logger.flush()\n\t\t\tparentPort?.postMessage({ event: 'stop', payload: 'exit' })\n\t\t\tparentPort?.close()\n\t\t\tprocess.exit()\n\t\t}\n\t}\n}\n\nfunction getCommandKey(interaction: AutocompleteInteraction | CommandInteraction) {\n\tconst commandKeys = [interaction.commandName]\n\tif (hasProperties<{ getSubcommandGroup: () => string }>(interaction.options, ['getSubcommandGroup'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommandGroup())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\tif (hasProperties<{ getSubcommand: () => string }>(interaction.options, ['getSubcommand'])) {\n\t\ttry {\n\t\t\tcommandKeys.push(interaction.options.getSubcommand())\n\t\t} catch {\n\t\t\t// Ignore\n\t\t}\n\t}\n\treturn commandKeys.filter(Boolean).join(' ')\n}\n\nfunction loadPluginData() {\n\tconst config = getConfig()\n\tconst collection = new Collection<string, PluginData>()\n\tif (!config.plugins) {\n\t\treturn collection\n\t}\n\n\tfor (const plugin of config.plugins) {\n\t\tif (typeof plugin === 'string') {\n\t\t\tcollection.set(plugin, { name: plugin })\n\t\t} else if (Array.isArray(plugin)) {\n\t\t\tconst [name, options, metaOptions] = plugin\n\t\t\tcollection.set(name, { name, options, metaOptions })\n\t\t}\n\t}\n\n\treturn collection\n}\n"]}