{"version":3,"sources":["../../src/core/handlers.ts"],"names":["portal","getSage","timeout","getConfig","BUFFER","DEFAULT_CONFIG","TIMEOUT","discordLogger","printErrorResponse","color","path","optionPrimitives","executeAutocompleteHandler","interaction","commandKey","command","middleware","result","error","config","promises","timeoutDuration","response","executeCommandHandler","commandConfig","sage","patchDeferReply","options","extractCommandOptions","bufferTime","raceResult","message","reply","isValidReply","executeContextHandler","target","executeEventHandler","plugins","eventName","eventData","callbacks","isLifecycleEvent","callback","handlerPromise","timeoutPromise","metaOptions","nestedError","createCommandConfig","commandOptions","option","optionValue","originalDeferReply","deferredPromise","alreadyDeferredWithMessage"],"mappings":"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","sourcesContent":["import { portal } from './robo.js'\nimport { CommandInteraction, ContextMenuCommandInteraction } from 'discord.js'\nimport { getSage, timeout } from '../cli/utils/utils.js'\nimport { getConfig } from './config.js'\nimport { BUFFER, DEFAULT_CONFIG, TIMEOUT, discordLogger } from './constants.js'\nimport { printErrorResponse } from './debug.js'\nimport { color } from './color.js'\nimport path from 'node:path'\nimport type { AutocompleteInteraction, InteractionDeferReplyOptions, Message } from 'discord.js'\nimport type { CommandConfig, ContextConfig, Event, HandlerRecord, PluginData } from '../types/index.js'\nimport type { Collection } from 'discord.js'\n\nconst optionPrimitives = ['boolean', 'integer', 'number', 'string', undefined]\n\nexport async function executeAutocompleteHandler(interaction: AutocompleteInteraction, commandKey: string) {\n\tconst command = portal.commands.get(commandKey)\n\tif (!command) {\n\t\tdiscordLogger.error(`No command matching ${commandKey} was found.`)\n\t\treturn\n\t}\n\n\t// Check if the autocomplete command's module is enabled\n\tif (!portal.module(command.module).isEnabled) {\n\t\tdiscordLogger.debug(`Tried to execute disabled command from module: ${color.bold(command.module)}`)\n\t\treturn\n\t}\n\n\t// Execute middleware\n\ttry {\n\t\tfor (const middleware of portal.middleware) {\n\t\t\tdiscordLogger.debug(\n\t\t\t\t`Executing middleware: ${color.bold(path.join(middleware.plugin?.path ?? '.', middleware.path))}`\n\t\t\t)\n\t\t\tconst result = await middleware.handler.default({\n\t\t\t\tpayload: [interaction],\n\t\t\t\trecord: command\n\t\t\t})\n\n\t\t\tif (result && result.abort) {\n\t\t\t\tdiscordLogger.debug(`Middleware aborted autocomplete: ${color.bold(interaction.commandName)}`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tdiscordLogger.error('Aborting due to middleware error:', error)\n\t\treturn\n\t}\n\n\tconst config = getConfig()\n\ttry {\n\t\t// Delegate to autocomplete handler\n\t\tdiscordLogger.debug(\n\t\t\t`Executing autocomplete handler: ${color.bold(path.join(command.plugin?.path ?? '.', command.path))}`\n\t\t)\n\t\tconst promises = [command.handler.autocomplete(interaction)]\n\t\tconst timeoutDuration = config?.timeouts?.autocomplete\n\n\t\t// Enforce timeout only if custom timeout is configured\n\t\tif (timeoutDuration) {\n\t\t\tpromises.push(timeout((): unknown[] => [], timeoutDuration))\n\t\t}\n\n\t\t// Wait for response or timeout\n\t\tconst response = await Promise.race(promises)\n\t\tif (!response) {\n\t\t\tthrow new Error('Autocomplete timed out')\n\t\t}\n\n\t\tawait interaction.respond(response)\n\t} catch (error) {\n\t\tdiscordLogger.error('Autocomplete error:', error)\n\t}\n}\n\nexport async function executeCommandHandler(interaction: CommandInteraction, commandKey: string) {\n\t// Find command handler\n\tconst command = portal.commands.get(commandKey)\n\tif (!command) {\n\t\tdiscordLogger.error(`No command matching \"${commandKey}\" was found.`)\n\t\treturn\n\t}\n\n\t// Check if the command's module is enabled\n\tif (!portal.module(command.module).isEnabled) {\n\t\tdiscordLogger.debug(`Tried to execute disabled command from module: ${color.bold(command.module)}`)\n\t\treturn\n\t}\n\n\t// Execute middleware\n\ttry {\n\t\tfor (const middleware of portal.middleware) {\n\t\t\tdiscordLogger.debug(\n\t\t\t\t`Executing middleware: ${color.bold(path.join(middleware.plugin?.path ?? '.', middleware.path))}`\n\t\t\t)\n\t\t\tconst result = await middleware.handler.default({\n\t\t\t\tpayload: [interaction],\n\t\t\t\trecord: command\n\t\t\t})\n\n\t\t\tif (result && result.abort) {\n\t\t\t\tdiscordLogger.debug(`Middleware aborted command: ${color.bold(commandKey)}`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tdiscordLogger.error('Aborting due to middleware error:', error)\n\t\treturn\n\t}\n\n\t// Prepare options and config\n\tconst commandConfig: CommandConfig = command.handler.config\n\tconst config = getConfig()\n\tconst sage = getSage(commandConfig, config)\n\tdiscordLogger.debug(`Sage options:`, sage)\n\n\ttry {\n\t\tdiscordLogger.debug(\n\t\t\t`Executing command handler: ${color.bold(path.join(command.plugin?.path ?? '.', command.path))}`\n\t\t)\n\t\tif (!command.handler.default) {\n\t\t\tthrow `Missing default export function for command: ${color.bold('/' + commandKey)}`\n\t\t}\n\n\t\t// Patch deferReply to prevent failures due to multiple deferrals\n\t\tpatchDeferReply(interaction)\n\n\t\t// Delegate to command handler\n\t\tconst options = extractCommandOptions(interaction, commandConfig?.options)\n\t\tconst result = command.handler.default(interaction, options)\n\t\tconst promises = []\n\t\tlet response\n\n\t\tif (sage.defer && result instanceof Promise) {\n\t\t\tconst bufferTime = timeout(() => BUFFER, sage.deferBuffer)\n\t\t\tconst raceResult = await Promise.race([result, bufferTime])\n\n\t\t\tif (raceResult === BUFFER && !interaction.replied) {\n\t\t\t\tdiscordLogger.debug(`Sage is deferring async command...`)\n\t\t\t\tpromises.push(result)\n\n\t\t\t\tif (!interaction.deferred) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tawait interaction.deferReply({ ephemeral: sage.ephemeral })\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tconst message = error instanceof Error ? error.message : (error as string)\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t!message.includes('Unknown interaction') &&\n\t\t\t\t\t\t\t!message.includes('Interaction has already been acknowledged')\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthrow error\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiscordLogger.debug(`Interaction was already handled, skipping Sage deferral`)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse = raceResult\n\t\t\t}\n\t\t} else if (result instanceof Promise) {\n\t\t\tpromises.push(result)\n\t\t}\n\n\t\t// Enforce timeout only if custom timeout is configured\n\t\tif (promises.length > 0) {\n\t\t\tif (config?.timeouts?.commandDeferral) {\n\t\t\t\tpromises.push(timeout(() => TIMEOUT, config.timeouts.commandDeferral))\n\t\t\t}\n\n\t\t\t// Wait for response or timeout\n\t\t\tresponse = await Promise.race(promises)\n\t\t\tif (response === TIMEOUT) {\n\t\t\t\tthrow new Error('Command timed out')\n\t\t\t}\n\t\t} else if (!(result instanceof Promise)) {\n\t\t\tresponse = result\n\t\t}\n\n\t\t// Stop here if command returned nothing\n\t\tif (response === undefined) {\n\t\t\tdiscordLogger.debug('Command returned void, skipping response')\n\t\t\treturn\n\t\t}\n\n\t\tdiscordLogger.debug(`Sage is handling reply:`, response)\n\t\tconst reply = typeof response === 'string' ? { content: response } : response\n\t\tconst isValidReply = !reply.id\n\t\tif (isValidReply && interaction.deferred) {\n\t\t\t// TODO: Fix reply objects themselves being used here\n\t\t\tawait interaction.editReply(reply)\n\t\t} else if (isValidReply) {\n\t\t\tawait interaction.reply(reply)\n\t\t} else {\n\t\t\tconst command = color.bold('/' + commandKey)\n\t\t\tdiscordLogger.warn(`Invalid return value for command ${command}. Did you accidentally return a message object?`)\n\t\t}\n\t} catch (error) {\n\t\tdiscordLogger.error(error)\n\t\tprintErrorResponse(error, interaction)\n\t}\n}\n\nexport async function executeContextHandler(interaction: ContextMenuCommandInteraction, commandKey: string) {\n\t// Find command handler\n\tconst command = portal.context.get(commandKey)\n\tif (!command) {\n\t\tdiscordLogger.error(`No context menu command matching \"${commandKey}\" was found.`)\n\t\treturn\n\t}\n\n\t// Check if the context menu's module is enabled\n\tif (!portal.module(command.module).isEnabled) {\n\t\tdiscordLogger.debug(`Tried to execute disabled context menu command from module: ${color.bold(command.module)}`)\n\t\treturn\n\t}\n\n\t// Execute middleware\n\ttry {\n\t\tfor (const middleware of portal.middleware) {\n\t\t\tdiscordLogger.debug(\n\t\t\t\t`Executing middleware: ${color.bold(path.join(middleware.plugin?.path ?? '.', middleware.path))}`\n\t\t\t)\n\t\t\tconst result = await middleware.handler.default({\n\t\t\t\tpayload: [interaction],\n\t\t\t\trecord: command\n\t\t\t})\n\n\t\t\tif (result && result.abort) {\n\t\t\t\tdiscordLogger.debug(`Middleware aborted context command: ${color.bold(commandKey)}`)\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t} catch (error) {\n\t\tdiscordLogger.error('Aborting due to middleware error:', error)\n\t\treturn\n\t}\n\n\t// Prepare options and config\n\tconst commandConfig: ContextConfig = command.handler.config\n\tconst config = getConfig()\n\tconst sage = getSage(commandConfig, config)\n\tdiscordLogger.debug(`Sage options:`, sage)\n\n\ttry {\n\t\tdiscordLogger.debug(\n\t\t\t`Executing context menu handler: ${color.bold(path.join(command.plugin?.path ?? '.', command.path))}`\n\t\t)\n\t\tif (!command.handler.default) {\n\t\t\tthrow `Missing default export function for command: ${color.bold('/' + commandKey)}`\n\t\t}\n\n\t\t// Determine target\n\t\tlet target\n\t\tif (interaction.isMessageContextMenuCommand()) {\n\t\t\ttarget = interaction.targetMessage\n\t\t} else if (interaction.isUserContextMenuCommand()) {\n\t\t\ttarget = interaction.targetUser\n\t\t}\n\n\t\t// Delegate to context menu handler\n\t\tconst result = command.handler.default(interaction, target)\n\t\tconst promises = []\n\t\tlet response\n\n\t\tif (sage.defer && result instanceof Promise) {\n\t\t\tconst bufferTime = timeout(() => BUFFER, sage.deferBuffer)\n\t\t\tconst raceResult = await Promise.race([result, bufferTime])\n\n\t\t\tif (raceResult === BUFFER && !interaction.replied) {\n\t\t\t\tdiscordLogger.debug(`Sage is deferring async command...`)\n\t\t\t\tpromises.push(result)\n\t\t\t\tif (!interaction.deferred) {\n\t\t\t\t\tawait interaction.deferReply({ ephemeral: sage.ephemeral })\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse = raceResult\n\t\t\t}\n\t\t}\n\n\t\t// Enforce timeout only if custom timeout is configured\n\t\tif (promises.length > 0) {\n\t\t\tif (config?.timeouts?.commandDeferral) {\n\t\t\t\tpromises.push(timeout(() => TIMEOUT, config.timeouts.commandDeferral))\n\t\t\t}\n\n\t\t\t// Wait for response or timeout\n\t\t\tresponse = await Promise.race(promises)\n\t\t\tif (response === TIMEOUT) {\n\t\t\t\tthrow new Error('Context menu command timed out')\n\t\t\t}\n\t\t} else if (!(result instanceof Promise)) {\n\t\t\tresponse = result\n\t\t}\n\n\t\t// Stop here if command returned nothing\n\t\tif (response === undefined) {\n\t\t\tdiscordLogger.debug('Context menu command returned void, skipping response')\n\t\t\treturn\n\t\t}\n\n\t\tdiscordLogger.debug(`Sage is handling reply:`, response)\n\t\tconst reply = typeof response === 'string' ? { content: response } : response\n\t\tif (interaction.deferred) {\n\t\t\tawait interaction.editReply(reply)\n\t\t} else {\n\t\t\tawait interaction.reply(reply)\n\t\t}\n\t} catch (error) {\n\t\tdiscordLogger.error(error)\n\t\tprintErrorResponse(error, interaction)\n\t}\n}\n\nexport async function executeEventHandler(\n\tplugins: Collection<string, PluginData> | null,\n\teventName: string,\n\t...eventData: unknown[]\n) {\n\tconst callbacks = portal.events.get(eventName)\n\tif (!callbacks?.length) {\n\t\treturn Promise.resolve()\n\t}\n\n\tconst config = getConfig()\n\tconst isLifecycleEvent = eventName.startsWith('_')\n\tawait Promise.all(\n\t\tcallbacks.map(async (callback: HandlerRecord<Event>) => {\n\t\t\ttry {\n\t\t\t\tdiscordLogger.debug(\n\t\t\t\t\t`Executing event handler: ${color.bold(path.join(callback.plugin?.path ?? '.', callback.path))}`\n\t\t\t\t)\n\t\t\t\tif (!callback.handler.default) {\n\t\t\t\t\tthrow `Missing default export function for event: ${color.bold(eventName)}`\n\t\t\t\t}\n\n\t\t\t\t// Check if the command's module is enabled\n\t\t\t\tif (!portal.module(callback.module).isEnabled) {\n\t\t\t\t\tdiscordLogger.debug(`Tried to execute disabled event from module: ${color.bold(callback.module)}`)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Execute middleware\n\t\t\t\ttry {\n\t\t\t\t\tfor (const middleware of portal.middleware) {\n\t\t\t\t\t\tdiscordLogger.debug(\n\t\t\t\t\t\t\t`Executing middleware: ${color.bold(path.join(middleware.plugin?.path ?? '.', middleware.path))}`\n\t\t\t\t\t\t)\n\t\t\t\t\t\tconst result = await middleware.handler.default({\n\t\t\t\t\t\t\tpayload: eventData,\n\t\t\t\t\t\t\trecord: callback\n\t\t\t\t\t\t})\n\n\t\t\t\t\t\tif (result && result.abort) {\n\t\t\t\t\t\t\tdiscordLogger.debug(`Middleware aborted event: ${color.bold(eventName)}`)\n\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch (error) {\n\t\t\t\t\tdiscordLogger.error('Aborting due to middleware error:', error)\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\t// Execute handler without timeout if not a lifecycle event\n\t\t\t\tconst handlerPromise = callback.handler.default(...eventData, plugins?.get(callback.plugin?.name)?.options)\n\t\t\t\tif (!isLifecycleEvent) {\n\t\t\t\t\treturn await handlerPromise\n\t\t\t\t}\n\n\t\t\t\t// Enforce timeouts for lifecycle events\n\t\t\t\tconst timeoutPromise = timeout(() => TIMEOUT, config?.timeouts?.lifecycle || DEFAULT_CONFIG.timeouts.lifecycle)\n\t\t\t\treturn await Promise.race([handlerPromise, timeoutPromise])\n\t\t\t} catch (error) {\n\t\t\t\ttry {\n\t\t\t\t\tconst metaOptions = plugins?.get(callback.plugin?.name)?.metaOptions ?? {}\n\t\t\t\t\tlet message\n\n\t\t\t\t\tif (error === TIMEOUT) {\n\t\t\t\t\t\tmessage = `${eventName} lifecycle event handler timed out`\n\t\t\t\t\t\tdiscordLogger.warn(message)\n\t\t\t\t\t} else if (!callback.plugin) {\n\t\t\t\t\t\tmessage = `Error executing ${eventName} event handler`\n\t\t\t\t\t\tdiscordLogger.error(message, error)\n\t\t\t\t\t} else if (eventName === '_start' && metaOptions.failSafe) {\n\t\t\t\t\t\tmessage = `${callback.plugin.name} plugin failed to start`\n\t\t\t\t\t\tdiscordLogger.warn(message, error)\n\t\t\t\t\t} else {\n\t\t\t\t\t\tmessage = `${callback.plugin.name} plugin error in event ${eventName}`\n\t\t\t\t\t\tdiscordLogger.error(message, error)\n\t\t\t\t\t}\n\n\t\t\t\t\t// Print error response to Discord if in development mode\n\t\t\t\t\tprintErrorResponse(error, eventData[0], message, callback)\n\t\t\t\t} catch (nestedError) {\n\t\t\t\t\tdiscordLogger.error(`Error handling event error...`, nestedError)\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t)\n}\n\ntype ExactConfig<C extends CommandConfig> = {\n\t[K in keyof C]: K extends keyof CommandConfig ? C[K] : never\n}\n\ntype EnforceConfig<C extends CommandConfig> = Exclude<keyof C, keyof CommandConfig> extends never\n\t? C\n\t: 'Extra properties are not allowed in CommandConfig'\n\nexport function createCommandConfig<C extends CommandConfig>(config: ExactConfig<C> & EnforceConfig<C>): C {\n\treturn config as C\n}\n\n/**\n * Extracts command options from a Discord interaction\n */\nexport function extractCommandOptions(interaction: CommandInteraction, commandOptions: CommandConfig['options']) {\n\tconst options: Record<string, unknown> = {}\n\n\tcommandOptions?.forEach((option) => {\n\t\tif (optionPrimitives.includes(option.type)) {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.value\n\t\t} else if (option.type === 'attachment') {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.attachment\n\t\t} else if (option.type === 'channel') {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.channel\n\t\t} else if (option.type === 'mention') {\n\t\t\tconst optionValue = interaction.options.get(option.name)\n\t\t\toptions[option.name] = optionValue?.member ?? optionValue?.role\n\t\t} else if (option.type === 'role') {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.role\n\t\t} else if (option.type === 'user') {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.user\n\t\t} else if (option.type === 'member') {\n\t\t\toptions[option.name] = interaction.options.get(option.name)?.member\n\t\t}\n\t})\n\n\treturn options\n}\n\nfunction patchDeferReply(interaction: CommandInteraction) {\n\tconst originalDeferReply = interaction.deferReply.bind(interaction)\n\tlet deferredPromise: Promise<void> | Promise<Message> | undefined\n\tlet alreadyDeferredWithMessage = false\n\n\t// @ts-expect-error - Patch the deferReply method to prevent multiple deferrals\n\tinteraction.deferReply = async function (\n\t\tthis: CommandInteraction,\n\t\toptions?: InteractionDeferReplyOptions\n\t): Promise<void | Message> {\n\t\t// If it's already been called, just return the stored promise\n\t\tif (deferredPromise) {\n\t\t\t// If user requests fetchReply this time but it wasn't fetched previously, just fetch it now.\n\t\t\tif (options?.fetchReply && !alreadyDeferredWithMessage) {\n\t\t\t\treturn this.fetchReply()\n\t\t\t}\n\n\t\t\treturn deferredPromise\n\t\t}\n\n\t\t// If not called yet:\n\t\tif (options?.fetchReply) {\n\t\t\t// @ts-expect-error - Defer and fetch the message right away\n\t\t\tdeferredPromise = originalDeferReply(options)\n\t\t\talreadyDeferredWithMessage = true\n\t\t\treturn deferredPromise\n\t\t} else {\n\t\t\t// @ts-expect-error - Defer without fetching\n\t\t\tdeferredPromise = originalDeferReply(options)\n\t\t\treturn deferredPromise\n\t\t}\n\t}\n}\n"]}