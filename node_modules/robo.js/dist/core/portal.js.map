{"version":3,"sources":["../../src/core/portal.ts"],"names":["Compiler","Collection","path","pathToFileURL","hasProperties","logger","color","composeColors","hex","getConfig","Globals","Portal","moduleName","moduleInstance","Module","apis","loadHandlerRecords","commands","context","events","middleware","_moduleName","_enabledModules","value","getPluginOptions","packageName","pluginOptions","plugin","scanEntries","predicate","options","manifestEntries","parentEntry","recursionKeys","type","promises","entryName","entryItem","entry","entryKeys","mergedEntry","resursion","collection","manifest","pcolor","formatter","api","command","event","handlers","scanPredicate","basePath","importPath","handler","eventKey","commandKey","contextKey"],"mappings":"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","sourcesContent":["import { Compiler } from './../cli/utils/compiler.js'\nimport { Collection } from 'discord.js'\nimport path from 'node:path'\nimport { pathToFileURL } from 'node:url'\nimport { hasProperties } from '../cli/utils/utils.js'\nimport { logger } from './logger.js'\nimport { color, composeColors, hex } from './color.js'\nimport { getConfig } from './config.js'\nimport type { Api, BaseConfig, Command, Context, Event, HandlerRecord, Middleware } from '../types/index.js'\nimport { Globals } from './globals.js'\n\nexport default class Portal {\n\tprivate _enabledModules: Record<string, boolean> = {}\n\tprivate _modules: Record<string, Module> = {}\n\n\tconstructor() {}\n\n\tget apis() {\n\t\treturn Globals.getPortalValues().apis\n\t}\n\n\tget commands() {\n\t\treturn Globals.getPortalValues().commands\n\t}\n\n\tget context() {\n\t\treturn Globals.getPortalValues().context\n\t}\n\n\tget events() {\n\t\treturn Globals.getPortalValues().events\n\t}\n\n\tget middleware() {\n\t\treturn Globals.getPortalValues().middleware\n\t}\n\n\tget moduleKeys() {\n\t\treturn Globals.getPortalValues().moduleKeys\n\t}\n\n\tmodule(moduleName: string) {\n\t\tlet moduleInstance = this._modules[moduleName]\n\t\tif (!moduleInstance) {\n\t\t\tmoduleInstance = new Module(moduleName, this._enabledModules)\n\t\t\tthis._modules[moduleName] = moduleInstance\n\t\t}\n\t\treturn moduleInstance\n\t}\n\n\t/**\n\t * Populates the Portal instance from the manifest file.\n\t *\n\t * Warning: Do not call this method directly. Use the `portal` export instead.\n\t */\n\tpublic static async open() {\n\t\tconst apis = await loadHandlerRecords<HandlerRecord<Api>>('api')\n\t\tconst commands = await loadHandlerRecords<HandlerRecord<Command>>('commands')\n\t\tconst context = await loadHandlerRecords<HandlerRecord<Context>>('context')\n\t\tconst events = await loadHandlerRecords<HandlerRecord<Event>[]>('events')\n\t\tconst middleware = [...(await loadHandlerRecords<HandlerRecord<Middleware>>('middleware')).values()]\n\n\t\tGlobals.registerPortal(apis, commands, context, events, middleware)\n\t}\n}\n\nclass Module {\n\tconstructor(private _moduleName: string, private _enabledModules: Record<string, boolean>) {}\n\n\tget isEnabled(): boolean {\n\t\treturn this._enabledModules[this._moduleName] ?? true\n\t}\n\n\tsetEnabled(value: boolean) {\n\t\tthis._enabledModules[this._moduleName] = value\n\t}\n}\n\n/**\n * Gets the config options for a specific plugin package.\n *\n * @param packageName The name of the package to get the options for.\n * @returns The options for the package, or null if the package is not installed nor configured.\n */\nexport function getPluginOptions(packageName: string): unknown | null {\n\tconst config = getConfig()\n\tconst pluginOptions = config.plugins?.find((plugin) => {\n\t\treturn (typeof plugin === 'string' ? plugin : plugin[0]) === packageName\n\t})\n\tconst options = typeof pluginOptions === 'string' ? null : pluginOptions?.[1]\n\n\treturn options ?? null\n}\n\ninterface ScanOptions<T> {\n\tmanifestEntries: Record<string, T | T[]> | T[]\n\tparentEntry?: T\n\trecursionKeys?: string[]\n\ttype: string\n}\ntype ScanPredicate = <T>(entry: T, entryKeys: string[]) => Promise<void>\n\nasync function scanEntries<T>(predicate: ScanPredicate, options: ScanOptions<T>) {\n\tconst { manifestEntries, parentEntry = {}, recursionKeys = [], type } = options\n\tconst promises: Promise<unknown>[] = []\n\n\tfor (const entryName in manifestEntries) {\n\t\tconst entryItem =\n\t\t\tArray.isArray(manifestEntries) && type !== 'middleware'\n\t\t\t\t? (manifestEntries as T[])\n\t\t\t\t: (manifestEntries as Record<string, T | T[]>)[entryName]\n\t\tconst entries = Array.isArray(entryItem) ? entryItem : [entryItem]\n\n\t\tentries.forEach((entry) => {\n\t\t\tconst entryKeys = [...recursionKeys, entryName]\n\t\t\tconst mergedEntry = { ...parentEntry, ...entry }\n\t\t\tpromises.push(predicate(mergedEntry, entryKeys))\n\n\t\t\tif (hasProperties<{ subcommands: Record<string, T> }>(entry, ['subcommands']) && entry.subcommands) {\n\t\t\t\tconst resursion = scanEntries(predicate, {\n\t\t\t\t\tmanifestEntries: entry.subcommands,\n\t\t\t\t\tparentEntry: mergedEntry,\n\t\t\t\t\trecursionKeys: entryKeys,\n\t\t\t\t\ttype\n\t\t\t\t})\n\t\t\t\tpromises.push(resursion)\n\t\t\t} else if (hasProperties<{ subroutes: Record<string, T> }>(entry, ['subroutes']) && entry.subroutes) {\n\t\t\t\tconst resursion = scanEntries(predicate, {\n\t\t\t\t\tmanifestEntries: entry.subroutes,\n\t\t\t\t\tparentEntry: mergedEntry,\n\t\t\t\t\trecursionKeys: entryKeys,\n\t\t\t\t\ttype\n\t\t\t\t})\n\t\t\t\tpromises.push(resursion)\n\t\t\t}\n\t\t})\n\t}\n\n\treturn Promise.all(promises)\n}\n\nasync function loadHandlerRecords<T extends HandlerRecord | HandlerRecord[]>(\n\ttype: 'api' | 'commands' | 'context' | 'events' | 'middleware'\n) {\n\tconst collection = new Collection<string, T>()\n\tconst manifest = Compiler.getManifest()\n\n\t// Log manifest objects as debug info\n\tconst pcolor =\n\t\ttype === 'commands'\n\t\t\t? composeColors(color.blue, color.bold)\n\t\t\t: type === 'context'\n\t\t\t? composeColors(hex('#536DFE'), color.bold)\n\t\t\t: type === 'events'\n\t\t\t? composeColors(color.magenta, color.bold)\n\t\t\t: composeColors(color.gray, color.bold)\n\tconst formatApi = (api: string) => pcolor(`${api}`)\n\tconst formatCommand = (command: string) => pcolor(`/${command}`)\n\tconst formatContext = (context: string) => pcolor(`${context} (${context})`)\n\tconst formatEvent = (event: string) => pcolor(`${event} (${manifest.events[event].length})`)\n\tconst formatMiddleware = (middleware: string) => pcolor(manifest.middleware[parseInt(middleware)]?.__path)\n\tconst formatter =\n\t\ttype === 'api'\n\t\t\t? formatApi\n\t\t\t: type === 'commands'\n\t\t\t? formatCommand\n\t\t\t: type === 'context'\n\t\t\t? formatContext\n\t\t\t: type === 'events'\n\t\t\t? formatEvent\n\t\t\t: formatMiddleware\n\tconst handlers = Object.keys(manifest[type]).map(formatter)\n\tlogger.debug(`Loading ${type}: ${handlers.join(', ')}`)\n\n\tconst scanPredicate: ScanPredicate = async (entry: BaseConfig, entryKeys) => {\n\t\t// Skip for nested entries (no __path)\n\t\tif (!entry.__path) {\n\t\t\treturn\n\t\t}\n\n\t\t// Load the module\n\t\tconst basePath = path.join(process.cwd(), entry.__plugin?.path ?? '.')\n\t\tconst importPath = pathToFileURL(path.join(basePath, entry.__path)).toString()\n\n\t\tconst handler: HandlerRecord = {\n\t\t\tauto: entry.__auto,\n\t\t\tdescription: entry.description,\n\t\t\thandler: await import(importPath),\n\t\t\tkey: entryKeys.join('/'),\n\t\t\tmodule: entry.__module,\n\t\t\tpath: entry.__path,\n\t\t\tplugin: entry.__plugin,\n\t\t\ttype: type === 'events' ? 'event' : type === 'commands' ? 'command' : type\n\t\t}\n\n\t\t// Assign the handler to the collection, handling difference between types\n\t\tif (type === 'events') {\n\t\t\tconst eventKey = entryKeys[0]\n\t\t\tif (!collection.has(eventKey)) {\n\t\t\t\tcollection.set(eventKey, [] as T)\n\t\t\t}\n\t\t\tconst handlers = collection.get(eventKey) as HandlerRecord[]\n\t\t\thandlers.push(handler)\n\t\t} else if (type === 'commands') {\n\t\t\tconst commandKey = entryKeys.join(' ')\n\t\t\tcollection.set(commandKey, handler as T)\n\t\t} else if (type === 'context') {\n\t\t\tconst contextKey = entryKeys[0]\n\t\t\tcollection.set(contextKey, handler as T)\n\t\t} else if (type === 'middleware') {\n\t\t\tcollection.set(entryKeys[0], handler as T)\n\t\t} else if (type === 'api') {\n\t\t\tcollection.set(entryKeys.join('/'), handler as T)\n\t\t}\n\t}\n\n\t// Scan context a bit differently due to nesting\n\tif (type === 'context') {\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest.context.message, type })\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest.context.user, type })\n\t} else {\n\t\tawait scanEntries(scanPredicate, { manifestEntries: manifest[type], type })\n\t}\n\n\treturn collection\n}\n"]}