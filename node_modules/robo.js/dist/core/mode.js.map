{"version":3,"sources":["../../src/core/mode.ts"],"names":["color","logger","fork","_mode","_modeColor","Mode","colorMode","get","is","getModeColor","mode","Colors","hash","acc","char","setMode","modes","m","shardModes","longestMode","a","b","args","newArgs","ignoreArgs","arg","code","text"],"mappings":"AAAA,OAAS,SAAAA,MAAa,aACtB,OAAS,UAAAC,MAAc,cACvB,OAAS,QAAAC,MAAY,qBAErB,IAAIC,EAAuB,KACvBC,EAwBG,MAAMC,EAAO,OAAO,OAAO,CAAE,MAAOC,EAAW,IAAAC,EAAK,GAAAC,CAAG,CAAC,EAKxD,SAASC,EAAaC,EAAc,CAC1C,MAAMC,EAAS,CAACX,EAAM,KAAMA,EAAM,KAAMA,EAAM,IAAKA,EAAM,OAAQA,EAAM,MAAOA,EAAM,OAAO,EACrFY,EAAOF,EAAK,MAAM,EAAE,EAAE,OAAO,CAACG,EAAKC,IAASD,EAAMC,EAAK,WAAW,CAAC,EAAG,CAAC,EAE7E,OAAOH,EAAOC,EAAOD,EAAO,MAAM,CACnC,CAKO,SAASI,EAAQL,EAAc,CAEjCA,IACHP,EAAQO,GAIL,CAACP,GAAS,QAAQ,IAAI,WACzBA,EAAQ,QAAQ,IAAI,UAIrB,MAAMa,EACLb,GACG,MAAM,GAAG,GACT,QAASc,GAAMA,EAAE,MAAM,GAAG,CAAC,GAC3B,OAAO,OAAO,GAAK,CAAC,EACxBhB,EAAO,MAAM,qBAAsBe,CAAK,EAGxC,IAAIE,EAAa,KAEjB,GAAIF,EAAM,OAAS,EAAG,CACrB,MAAMG,EAAcH,EAAM,OAAO,CAACI,EAAGC,IAAOD,EAAE,OAASC,EAAE,OAASD,EAAIC,CAAE,EAExEH,EAAa,IAAM,CAElBF,EAAM,QAASN,GAAS,CAEvB,MAAMY,EAAO,QAAQ,KAAK,MAAM,CAAC,EAC3BC,EAAoB,CAAC,EAC3B,IAAIC,EAAa,GAEjBF,EAAK,QAASG,GAAQ,CACrB,GAAID,GAAcC,EAAI,WAAW,GAAG,EACnCD,EAAa,WACHA,EACV,OAGDD,EAAQ,KAAKE,CAAG,GACZA,IAAQ,UAAYA,IAAQ,QAC/BF,EAAQ,KAAKE,EAAKf,CAAI,EACtBc,EAAa,GAEf,CAAC,EAGatB,EAAK,QAAQ,KAAK,CAAC,EAAGqB,EAAS,CAC5C,IAAK,CACJ,GAAG,QAAQ,IACX,gBAAiBb,EACjB,iBAAkBM,EAAM,KAAK,GAAG,EAChC,wBAAyBG,CAC1B,CACD,CAAC,EAEK,GAAG,OAASO,GAAS,CAC1BzB,EAAO,MAAM,kCAAkCyB,GAAM,CACtD,CAAC,CACF,CAAC,CACF,OAGAtB,EAAaK,EAAaN,CAAK,EAGhC,MAAO,CAAE,WAAAe,CAAW,CACrB,CAMO,SAASZ,EAAUqB,EAAc,CACvC,OAAKvB,IACJA,EAAaK,EAAaN,CAAK,GAGzBC,EAAWuB,CAAI,CACvB,CAQA,SAASpB,GAAc,CAEtB,MAAI,CAACJ,GAAS,QAAQ,IAAI,WACzBA,EAAQ,QAAQ,IAAI,UAGdA,CACR,CAQA,SAASK,EAAGE,EAAc,CACzB,OAAOH,EAAI,IAAMG,CAClB","sourcesContent":["import { color } from './color.js'\nimport { logger } from './logger.js'\nimport { fork } from 'node:child_process'\n\nlet _mode: string | null = null\nlet _modeColor: (typeof color)[0]\n\n/**\n * Modes are a way to define \"profiles\" for your Robo session. Each with its own config(s), envionment variables, and code.\n *\n * ```ts\n * import { Mode } from 'robo.js'\n *\n * // Get the current mode\n * const mode = Mode.get()\n *\n * // Check if the current mode is \"dev\"\n * if (Mode.is('dev')) {\n *  // Do something\n * }\n *\n * // Colorize text based on the current mode\n * console.log(Mode.color('Hello, world!'))\n * ```\n *\n * Everything is granular. You can even run multiple modes at the same time!\n *\n * [**Learn more:** Mode](https://robojs.dev/robojs/mode)\n */\nexport const Mode = Object.freeze({ color: colorMode, get, is })\n\n/**\n * @internal\n */\nexport function getModeColor(mode: string) {\n\tconst Colors = [color.blue, color.cyan, color.red, color.yellow, color.green, color.magenta]\n\tconst hash = mode.split('').reduce((acc, char) => acc + char.charCodeAt(0), 0)\n\n\treturn Colors[hash % Colors.length]\n}\n\n/**\n * @internal\n */\nexport function setMode(mode: string) {\n\t// Only set mode to valid value, otherwise keep it as is\n\tif (mode) {\n\t\t_mode = mode\n\t}\n\n\t// Use the NODE_ENV if no mode is provided\n\tif (!_mode && process.env.NODE_ENV) {\n\t\t_mode = process.env.NODE_ENV\n\t}\n\n\t// See if there's multiple modes in this (e.g. \"dev, beta\")\n\tconst modes =\n\t\t_mode\n\t\t\t?.split(',')\n\t\t\t?.flatMap((m) => m.split(' '))\n\t\t\t?.filter(Boolean) ?? []\n\tlogger.debug(`Setting mode(s) to`, modes)\n\n\t// If there's multiple modes, return a way to shard\n\tlet shardModes = null\n\n\tif (modes.length > 1) {\n\t\tconst longestMode = modes.reduce((a, b) => (a.length > b.length ? a : b))\n\n\t\tshardModes = () => {\n\t\t\t// When multiple modes are provided, we need to shard the process\n\t\t\tmodes.forEach((mode) => {\n\t\t\t\t// Update args to remove all other mode flags\n\t\t\t\tconst args = process.argv.slice(2)\n\t\t\t\tconst newArgs: string[] = []\n\t\t\t\tlet ignoreArgs = false\n\n\t\t\t\targs.forEach((arg) => {\n\t\t\t\t\tif (ignoreArgs && arg.startsWith('-')) {\n\t\t\t\t\t\tignoreArgs = false\n\t\t\t\t\t} else if (ignoreArgs) {\n\t\t\t\t\t\treturn\n\t\t\t\t\t}\n\n\t\t\t\t\tnewArgs.push(arg)\n\t\t\t\t\tif (arg === '--mode' || arg === '-m') {\n\t\t\t\t\t\tnewArgs.push(arg, mode)\n\t\t\t\t\t\tignoreArgs = true\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\t// Launch a new process with the new args\n\t\t\t\tconst child = fork(process.argv[1], newArgs, {\n\t\t\t\t\tenv: {\n\t\t\t\t\t\t...process.env,\n\t\t\t\t\t\tROBO_SHARD_MODE: mode,\n\t\t\t\t\t\tROBO_SHARD_MODES: modes.join(','),\n\t\t\t\t\t\tROBO_SHARD_LONGEST_MODE: longestMode\n\t\t\t\t\t}\n\t\t\t\t})\n\n\t\t\t\tchild.on('exit', (code) => {\n\t\t\t\t\tlogger.debug(`Child process exited with code ${code}`)\n\t\t\t\t})\n\t\t\t})\n\t\t}\n\t} else {\n\t\t// Update mode color\n\t\t_modeColor = getModeColor(_mode)\n\t}\n\n\treturn { shardModes }\n}\n\n/**\n * Returns the color function for the current mode.\n * This is used to colorize logs based on the mode when multiple exist.\n */\nexport function colorMode(text: string) {\n\tif (!_modeColor) {\n\t\t_modeColor = getModeColor(_mode)\n\t}\n\n\treturn _modeColor(text)\n}\n\n/**\n * The current mode this Robo instance is running in.\n * This is set by the `--mode` CLI flag.\n *\n * Defaults to `production` for `robo start` and `development` for `robo dev`.\n */\nfunction get(): string {\n\t// Default to NODE_ENV\n\tif (!_mode && process.env.NODE_ENV) {\n\t\t_mode = process.env.NODE_ENV\n\t}\n\n\treturn _mode\n}\n\n/**\n * Checks if the current mode matches the provided mode.\n *\n * @param mode The mode to check against.\n * @returns `true` if the current mode matches the provided mode.\n */\nfunction is(mode: string) {\n\treturn get() === mode\n}\n"]}