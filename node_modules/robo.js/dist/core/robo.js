import { color } from './color.js';
import { registerProcessEvents } from './process.js';
import { Compiler } from './../cli/utils/compiler.js';
import { Client, Events, Collection } from 'discord.js';
import { loadConfig, getConfig } from './config.js';
import { discordLogger, FLASHCORE_KEYS } from './constants.js';
import { logger } from './logger.js';
import { env, Env } from './env.js';
import { executeEventHandler, executeCommandHandler, executeAutocompleteHandler, executeContextHandler } from './handlers.js';
import { PackageDir, hasProperties } from '../cli/utils/utils.js';
import { prepareFlashcore, Flashcore } from './flashcore.js';
import { Mode } from './mode.js';
import { loadState } from './state.js';
import h from './portal.js';
import J from 'node:path';
import { isMainThread, parentPort } from 'node:worker_threads';

const ce={restart:Y,start:T,stop:W,build:z};let r;const v=new h;let S;async function z(t){const{buildAction:o}=await import('../cli/commands/build/index.js');await o([],{exit:!1,...t??{}});}async function T(t){const{client:o,shard:s,stateLoad:d}=t??{};registerProcessEvents();const[a]=await Promise.all([loadConfig(),Compiler.useManifest()]);if(logger({drain:a?.logger?.drain,enabled:a?.logger?.enabled,level:a?.logger?.level}).debug("Starting Robo..."),s&&a.experimental?.disableBot!==!0){discordLogger.debug("Sharding is enabled. Delegating start to shard manager...");const{ShardingManager:e}=await import('discord.js'),n=typeof s=="string"?s:J.join(PackageDir,"dist","cli","shard.js"),l=typeof a.experimental?.shard=="object"?a.experimental.shard:{},b=new e(n,{...l,token:env.get("discord.token")});b.on("shardCreate",P=>discordLogger.debug("Launched shard",P.id));const O=await b.spawn();discordLogger.debug("Spawned",O.size,"shard(s)");return}const g=Mode.get();if(await Env.load({mode:g}),await prepareFlashcore(),d)logger.debug("Waiting for state..."),await d;else {const e=Date.now(),n=await Flashcore.get(FLASHCORE_KEYS.state);n&&loadState(n),logger.debug(`State loaded in ${Date.now()-e}ms`);}const f=q();if(a.experimental?.disableBot!==!0?r=o??new Client(a.clientOptions):logger.debug("Bot is disabled, skipping client setup..."),await h.open(),await executeEventHandler(f,"_start",r),a.experimental?.disableBot!==!0){for(const e of v.events.keys()){const n=v.events.get(e).every(l=>l.auto);r.on(e,async(...l)=>{n||discordLogger.event(`Event received: ${color.bold(e)}`),discordLogger.trace("Event args:",l),executeEventHandler(f,e,...l);});}r.on(Events.InteractionCreate,async e=>{if(e.isChatInputCommand()){const n=C(e);discordLogger.event(`Received slash command interaction: ${color.bold("/"+n)}`),discordLogger.trace("Slash command interaction:",e.toJSON()),await executeCommandHandler(e,n);}else if(e.isAutocomplete()){const n=C(e);discordLogger.event(`Received autocomplete interaction for: ${color.bold(e.commandName)}`),discordLogger.trace("Autocomplete interaction:",e.toJSON()),await executeAutocompleteHandler(e,n);}else e.isContextMenuCommand()&&(discordLogger.event(`Received context menu interaction: ${color.bold(e.commandName)}`),discordLogger.trace("Context menu interaction:",e.toJSON()),await executeContextHandler(e,e.commandName));}),await r.login(env.get("discord.token"));}}async function W(t=0){try{await executeEventHandler(S,"_stop",r),r?.destroy(),logger.debug("Stopped Robo at "+new Date().toLocaleString());}finally{isMainThread||(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close()),process.exit(t);}}async function Y(){try{await executeEventHandler(S,"_restart",r),r?.destroy(),logger.debug("Restarted Robo at "+new Date().toLocaleString());}finally{isMainThread?process.exit(0):(await logger.flush(),parentPort?.postMessage({event:"stop",payload:"exit"}),parentPort?.close(),process.exit());}}function C(t){const o=[t.commandName];if(hasProperties(t.options,["getSubcommandGroup"]))try{o.push(t.options.getSubcommandGroup());}catch{}if(hasProperties(t.options,["getSubcommand"]))try{o.push(t.options.getSubcommand());}catch{}return o.filter(Boolean).join(" ")}function q(){const t=getConfig(),o=new Collection;if(!t.plugins)return o;for(const s of t.plugins)if(typeof s=="string")o.set(s,{name:s});else if(Array.isArray(s)){const[d,a,g]=s;o.set(d,{name:d,options:a,metaOptions:g});}return o}

export { ce as Robo, z as build, r as client, v as portal };
//# sourceMappingURL=out.js.map
//# sourceMappingURL=robo.js.map